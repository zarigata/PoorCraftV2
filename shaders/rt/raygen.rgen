#version 460
#extension GL_EXT_ray_tracing : require

// Descriptor bindings - Set 0 only
// Set 0, Binding 0: Storage image
layout(set = 0, binding = 0, rgba8) uniform image2D outputImage;

// Set 0, Binding 1: Camera uniform buffer
layout(set = 0, binding = 1) uniform CameraUBO {
    mat4 view;
    mat4 projection;
    mat4 invView;
    mat4 invProjection;
    vec3 position;
    float _pad0;
    vec3 sunDirection;
    float _pad1;
    vec3 sunColor;
    float _pad2;
    vec3 skyTopColor;
    float _pad3;
    vec3 skyHorizonColor;
    float ambientStrength;
    float timeOfDay;
} camera;

void main() {
    // Calculate pixel coordinates
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    // Transform to world space ray direction
    vec4 target = camera.invProjection * vec4(d.x, d.y, 1, 1);
    vec4 direction = camera.invView * vec4(normalize(target.xyz), 0);
    vec3 rayDir = normalize(direction.xyz);

    // MVP: Generate gradient based on ray direction instead of tracing
    // Gradient from horizon to zenith
    float gradientFactor = max(0.0, rayDir.y);
    vec3 skyColor = mix(camera.skyHorizonColor, camera.skyTopColor, gradientFactor);
    
    // Add sun contribution
    float sunDot = max(0.0, dot(rayDir, camera.sunDirection));
    if (sunDot > 0.99) {
        float sunIntensity = pow(sunDot, 100.0);
        skyColor += camera.sunColor * sunIntensity;
    }

    // Write result to output image
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(skyColor, 1.0));
}
